<!--

 * @Description: 
 * @version: 
 * @Author: 帅磊240108 2158097607@xiaomi.com
 * @Date: 2024-08-30 23:10:10
 * @LastEditors: ShuaiLei
 * @LastEditTime: 2024-11-02 16:35:16
-->
[TOC]

# 一、C++基础语法

## 1.1.main函数在执行之前和之后执行的代码可能是什么？
main函数在执行之前一般都会初始化系统相关资源

(1)设置栈指针

(2)初始化静态变量和全局变量

(3)将未初始化的全局变量赋初值

(4)全局对象初始化，在main之前调用构造函数

(5)将main函数参数传递给main函数

main函数执行之后

(1)全局对象的析构函数会在main函数之后执行

## 1.1.拓展
.data 段: 存储已初始化的全局和静态变量，初始值在程序开始运行时已经设置好

.bss 段: 存储未初始化的全局和静态变量，在程序启动时自动初始化为零。

## 1.2.结构体的内存对齐

### 1.2.1.内存对齐的优点

(1)提高内存访问速度

(2)减少内存访问的速度

(3)优化硬件性能

(4)减少编译器优化困难

(5)避免内存碎片

### 1.2.2.结构体内存对齐
结构体成员按声明顺序存储，第一个成员地址和结构体地址相同

没有特殊声明时，一般按照size最大的成员对齐

## 1.3.指针与引用的区别
（1）指针是一个变量，存储的是一个地址，引用跟原来的变量实质是一个东西，是别名

（2）指针可以为空，但是引用不能为空，而且引用在定义的时候必须要初始化，初始化后不可再改变

（3）sizeof指针得到的是指针的大小，sizeof引用得到的是引用所指向变量的大小

（4）不存在指向空值的引用，但存在指向空值的指针

## 1.4.关于传递参数使用引用还是指针

需要返回函数内部局部变量的时候用指针

对栈空间比较敏感的时候例如递归的时候选用引用

类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式


## 1.5.堆与栈的区别

申请方式不同：栈是由系统自动分配的，堆是自己申请和释放的

申请大小限制不同：栈顶和栈底是之前预设的，大小固定

申请效率不同：栈由系统分配，速度快，不会有碎片，堆由程序员分配，速度慢，会有碎片

分配方式：堆都是动态分配的，栈有静态分配和动态分配

空间大小：堆是不连续的内存区域，堆的空间比较大，比较灵活。栈是连续的内存区域，大小是操作系统预订好的

分配效率：堆由C++函数库提供，机制复杂，堆的效率比栈低很多。栈是系统提供的数据结构，计算机在底层对栈提供支持

## 1.6.堆快一点还是栈快一点

栈更快一点，操作系统对栈提供支持，会分配专门的寄存器存放地址，栈的出栈入栈也比较简单，有专门的指令执行，栈的效率比较高也比较快

堆的操作是C/C++函数库提供的，在分配内存的时候需要一定的算法寻找合适的内存

## 1.7.区别函数组指针、指针数组、函数声明、函数指针

~~~cpp
int *p[10]  // 指针数组
int (*p)[10]  // 数组指针
int *p(int)  // 函数声明
int (*p)(int) // 函数指针
~~~

## 1.8.new/delete以及malloc/free异同

相同点：都用于内存的申请和释放

不同点：

（1）new和delete是C++的运算符，malloc和free是C语言标准库函数

（2）new是自动分配大小的，malloc需要手工计算，new是类型安全的，malloc不是的

（3）new和delete会调用构造函数和析构函数，malloc/free不会

（4）malloc/free需要库文件，new/delete没有


## 1.9.new和delete是如何实现的

（1）new实现的过程，首先调用operator new的标准库函数，分配足够大的内存，接下来运行构造函数，指定初始化构造对象，返回这个对象的指针。

（2）delete实现的过程，对指针指向的对象运行析构函数，调用名为operator delete的标注库函数释放内存。


## 1.10.malloc和new的区别

（1）malloc和free是标准库函数，new和delete是运算符，支持重载

（2）使用new分配内存空间时无需指定分配的大小，使用malloc需要指定分配的大小

（3）malloc和free仅仅分配和回收内存空间，不能调用构造和析构函数，而new/delete会调用

（4）malloc返回的是void类型指针，需要强制转换类型，new直接返回相对应的类型指针

（5）malloc分配失败会返回NULL，new分配失败会返回bad_alloc

| 分配方式               | malloc       | new                    |
| ---------------------- | ------------ | ---------------------- |
| 是否是标准库           | 是           | 否，是运算符，支持重载 |
| 是否需要指定大小       | 是           | 否                     |
| 是否调用构造和析构函数 | 否           | 是                     |
| 返回类型               | void类型指针 | 相应类型指针           |
| 分配失败               | NULL         | bad_alloc              |


## 1.11.已经有了malloc和free为什么C++还需要new和delete？

在对非基本数据类型的时候，需要构造和析构函数，所以需要new和delete

## 1.12.被free的内存会立即返回给操作系统吗？

被free的内存会被ptmalloc使用双链表保存起来，当下一次申请会找合适的返回，避免频繁的系统调用，占用过多的系统资源。

## 1.13.宏定义和函数的区别

（1）宏在预处理阶段完成替换，之后会参与编译，执行更快

（2）宏定义没有返回值

（3）宏定义没有参数类型，不需要类型检查

（4）宏定义语句没有分号

## 1.14.宏定义和typedef的区别

（1）宏主要用于常量替换，而typedef用于定义类型别名

（2）宏替换发生在编译前，属于文本插入替换，typedef是编译的一部分

（3）宏不会检测类型，typedef会检查类型

（4）宏不是语句，不需要加分号，typedef是语句，需要加分号

## 1.15.变量声明和定义的区别

（1）声明并不分配内存空间，定义会分配空间

（2）相同变量可以多处声明但是只能一次定义

## 1.16.strlen和sizeof的区别

（1）sizeof是运算符，strlen是字符处理的库函数

（2）sizeof参数可以是任何数据类型，strlen的参数只能是字符指针同时结尾是'\0'的字符串

## 1.17.常量指针和指针常量的区别

~~~cpp
int const *p; // 指针常量
int *const p; // 常量指针
~~~
（1）指针常量：指向一个只读的值

（2）常量指针：必须初始化，不变的是指针本身的值，而非指向的值

主要通过const修饰谁来判断，例如int const *p修饰的是 *p所以 *p不能被改变，是指针常量

int *const p其中const修饰的是p 所以p不能被改变，是常量指针

## 1.18.C++与C语言的区别

（1）面向对象和面向过程

C++支持面向对象，侧用使用类和对象来管理代码

C语言面向过程，侧重使用函数解决问题

（2）继承

C++支持继承，允许一个子类继承一个或者多个父类，达到代码复用的目的

C语言没有继承的概念

（3）函数重载

C++支持函数通过参数名和参数个数的重载

C语言不支持重载，函数名必须唯一

（4）模板

C++支持模板，支持静态和动态形式的多态

C语言不存在模板

（5）内存管理

C++使用new和delete管理内存

C语言使用malloc和free管理内存

（6）标准库

C++的STL的标准库比C语言的丰富

## 1.19.C++与java的区别

（1）java语言更为简洁，完全面向对象，JVM可以安装在任何操作系统上，可移植性强。

（2）java没有指针，引入了真正的数组，不会有数组操作等指针越界

（3）java使用接口（interface）代替了C++的抽象类

（4）内存管理，C++类和对象通过析构函数回收，而java不需要自己管理内存

（5）桌面程序C++更实用，web端java更方便

## 1.20.C++中的struct和class的区别

（1）两者都拥有成员函数，公有私有部分

（2）使用class完成的工作同样可以使用class完成

（3）成员如果不指定公私有，则class默认私有，struct默认公有

（4）class继承默认是私有继承，而struct是公有继承

## 1.21.C++与C语言的struct

（1）C语言中的struct是自定义数据类型，C++中struct是抽象数据类型，支持成员函数定义

（2）C语言的struct没有权限设置，成员不可以是函数

（3）C++中，struct增加了访问权限，且可以和类一样有成员函数

## 1.22.define宏定义和const的区别

（1）编译阶段

define在编译预处理阶段起作用，const在编译和运行的时候起作用

（2）安全性

define只做替换，不做类型检查和替换，const修饰的数据类型，编译器会对其进行类型安全检查

（3）内存占用

define替换后，内存中会有多个相同的备份，但宏定义的数据不会分配内存空间，const修饰的内存变量只是值不能改变，但还是会分配内存空间

## 1.23.C++中的static和const的作用

（1）static

static用于静态变量和函数，在程序执行期间只会初始化一次，并且离开作用域时不会被销毁。

类中的成员变量static只与类关联，不与类的对象关联

（2）const

用于定义常量，变量在初始化后不能被修改

防止变量被修改，增强代码可读性和安全性

## 1.24.C++的顶层const和底层const

（1）顶层const

const修饰的变量本身就是一个常量,const修饰的是整个对象，变量的值不可更改

~~~cpp
const int x = 10;  // x 是一个顶层 const 变量，x 的值不能被修改
int* const p2 = &y; // p2 是一个常量指针，p2 不能改变指向的地址，但可以通过 p2 修改 y
~~~

（2）底层const

指的是const修饰的变量所指向的对象是一个常量，修饰的是指针所指向的对象，指针所指向的内容不可修改

~~~cpp
int y = 20;
const int* p1 = &y; // p1 是指向 const int 的指针，不能通过 p1 修改 y
const int* const p3 = &y; // p3 是一个常量指针指向常量，p3 不能改变指向的地址，也不能通过 p3 修改 y
~~~

区分作用

（1）执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const

（2）使用的命名的强制类型转换const_cast时，只能改变运算对象的底层const

## 1.25.数组名和指针的区别

（1）二者均可以通过增减偏移量来访问数组中的元素

（2）数组名不是真正意义上的指针，可以理解为常量指针，所以数组名没有自增自减等操作

（3）数组名是常量指针，不能改变

## 1.26.什么是函数签名？

在C++中，函数签名是指函数的名称、参数列表和参数类型的组合，不包括函数的返回类型

函数签名的组成

（1）函数名：函数的名称

（2）参数列表：参数个数、类型、顺序，不包括参数名

不匹配的签名：

（1）参数类型和顺序不同

（2）参数个数不同

（3）函数返回类型不同：尽管返回类型不属于函数签名的一部分，但对于虚函数的重写，返回类型必须要和基类中的虚函数匹配。

## 1.27.override和final关键字

（1）override关键字

确保子类的函数正确的重写了基类中的虚函数。仅用于函数，尤其是虚函数的重写。编译器会检查函数签名是否一致，确保确实重写了虚函数

（2）final关键字

防止类被进一步继承或者防止虚函数被进一步重写。可用于类和虚函数

## 1.28.拷贝初始化和直接初始化

当用于类类型对象的时候，初始化的拷贝形式和直接形式有所不同：直接初始化会调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先会使用构造函数创建临时对象，然后拷贝构造函数将临时对象拷贝到创建的对象。

## 1.29.初始化和赋值的区别

（1）简单类型

初始化和赋值没有什么区别

（2）类对象

初始化：创建对象赋初值的过程，初始化发生在对象的创建阶段，是对象生命周期的开始

赋值：对象已经创建并初始化后，对值进行更新的过程，是对象生命周期的中间阶段

## 1.30.extern "C" 的用法

为了正确在C++中使用C，在程序中extern C后相当于告诉编译器这部分代码是C语言写的

（1）C++代码中使用C语言

（2）在C++头文件中使用

（3）用不同语言协同开发时

## 1.31.野指针与悬空指针

定义

（1）野指针：没有被初始化的指针。

（2）悬空指针：指针最初指向的内存已经被释放了的指针

解决方法

（1）野指针：定义指针变量时及时初始化或者置空。

（2）悬空指针：释放指针所指向的内存空间后及时置空。

## 1.32.C++的类型安全

（1）操作符new返回的具体类型的指针，而不是void*

（2）引入const关键字代表#define

（3）一些define宏可被改写为inline函数

（4）C++提供了dynamic_cast关键字

## 1.33.C++重载、重写以及隐藏的区别

（1）重载

是指同一范围定义中的同名成员函数才存在重载函数，主要特点是函数名相同，参数类型和数目不同，不能出现仅仅依靠返回值不同来区分的函数。重载与成员函数是否是虚函数无关。

（2）重写

是指在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须要是虚函数。重写的函数，参数类型、参数个数以及返回类型都必须相同

重写与重载的区别

* 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系

* 重写要求参数列表相同，重载要求参数列表不同，返回值不要求

* 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表之间关系选择函数体


（3）隐藏

是指某些情况下，派生类中的函数屏蔽了基类中的同名函数

* 两个函数参数相同，但是基类函数不是虚函数，和重写的区别就在于基类函数不是虚函数。

* 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏


## 1.34.C++有哪几种构造函数

默认构造函数

初始化构造函数

拷贝构造函数

移动构造函数

## 1.35.浅拷贝和深拷贝的区别

（1）浅拷贝

浅拷贝只是拷贝一个指针，拷贝的指针和原指针指向同一个地方，

（2）深拷贝

深拷贝不仅拷贝值，还开辟新的一片空间存放新的值

## 1.36.内联函数和宏定义的区别

（1）在使用时，宏只做简单的字符串替换，内联函数可以进行参数检查，具有返回值

（2）内联函数在编译时直接将函数代码直接嵌入到目标代码中，省去函数调用的开销，并进行参数类型检查，具有返回值

（3）宏定义需要注意格式，否则容易出现歧义，内联函数不会出现歧义

（4）内联函数有类型检查，语法判断等功能


## 1.37.public、protected、private访问继承权限/public/protected/private的区别

* public的变量和函数都可以在类的内部外部访问到

* protected的变量和函数都只可以类的内部和派生类中访问

* private修饰的元素只能在类内访问 

（一）访问权限

派生类对基类成员有两种访问方式

* 内部访问：由派生类的成员函数对基类中继承来的成员的访问

* 外部访问：在派生类外部，通过派生类的对象对基类中继承来的成员的访问

（二）继承权限

（1）派生类继承自基类的成员权限状态有：public、protected、private、不可见，排序为public>protected>private

（2）派生类对于基类成员的访问权限取决于两点：继承方式、基类成员在基类中的访问权限

（3）基类成员在派生类中的访问权限不得高于继承方式指定的权限：高于继承方式指定的权限则下降为继承权限，低于继承权限则不调整，基类的private成员在任何方式下都是不可见的，例如：

* public继承+private成员--->不可见
* public继承+protected成员--->pretected
* protected继承+public成员--->protected
* private继承+public成员--->private
* private继承+protected成员--->private

## 1.38.如何用代码判断大小端存储?

* 大端存储：字数据的高字节存储在低地址中

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |

* 小端存储：字数据的低字节存储在低地址中

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |

使用代码判断：

~~~cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
~~~

在socket编程中，需要用将小端存储的ip地址转为大端存储，才能进行网络传输

## 1.39.volatile、mutable和explicit关键字

* volatile关键字

volatile是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素修改。当遇到这个关键字修饰的变量，编译器对访问该变量的代码不再优化，提供对特殊地址的稳定访问。系统会从所在的内存去访问。多线程被几个任务共享的变量需要定义为volatile类型。

* mutable关键字

当需要在const函数里面修改一些与类状态无关的数据成员，这个函数就应该用multable来修饰

* explicit关键字

explicit是C++中的关键字，防止隐式转换，通常用于构造函数，防止编译器在某些情况下自动调用构造函数进行隐式转换，以确保代码的可读性和安全性。

## 1.40.什么情况下会调用拷贝构造函数？

* 在使用类的实例化对象去初始化另一个对象时
* 函数的参数是类的对象时（非引用传递）
* 函数返回值是函数体局部对象类对象时，这时会发生NRV优化，返回值是值传递，会调用拷贝构造函数（linux下g++不会发生拷贝构造函数）

## 1.41.new有几种方式？

new有三种方式：plain new、nothrow new、placement new。

（1）plain new

这个就是普通的new，也是最常用的new

（2）nothrow new

nothrow new分配的时候不抛出异常，会返回NULL

（3）placement new

placement new允许在一块已经分配好的内存上重新构造对象或者对象数组

placement new构造的对象数组，需要显示的调用析构函数释放，不能使用delete，否则可能导致内存泄漏等问题

## 1.42.C++的异常处理的方法？

（1）try、throw和catch关键字

（2）函数异常声明列表

在定义函数时，可能知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出的异常。

（3）C++标准异常类exception

exception包含的异常类：bad_typeid，bad_cast,bad_alloc,out_of_range

## 1.43.static用法和作用

（1）隐藏

（2）static是用来保持变量内容的持久

存储在静态区域的变量只会初始化一次，也是唯一一次初始化。静态区域变量：全局变量、静态变量

（3）static变量默认初始化为0

（4）C++类成员声明

* 函数体中static变量作用范围为函数体，下次调用会维持上次的值

* 在类中的static变量属于整个类所有，对类的所有对象只有一份拷贝

* static成员函数属于这个类，没有this指针，只能访问static成员变量

* static成员函数不能被virtual修饰

## 1.44.指针和const用法

顶层指针（常量指针）：指针本身是一个常量，const修饰的是p，指针的指向不能改变，但是可以改变指针指向的值。

~~~cpp
int* const p
~~~

底层指针（指针常量）：指针指向的变量是一个常量，const修饰的是*p，指针的内容不能改变，可以改变指针的指向。

~~~cpp
int const *p
~~~

## 1.45.形参与实参的区别

（1）形参只有在调用时分配内存，调用结束就会释放内存

（2）实参可以为值、对象、函数，必须要有确定的值

（3）形参与实参在类型、数量、顺序上必须一致

（4）函数调用时数据传输是单向的，即实参向形参传递

（5）当形参与实参不是指针时，他们是两份不同的变量

## 1.46.值传递、指针传递、引用传递的区别和效率？

值传递：当传递比较大的类对象或者结构体对象时，耗费较多的时间和空间。

指针传递：也和值传递一样会有一个拷贝的过程，但拷贝的是地址。

引用传递：相当于为地址取了一个别名

效率：指针传递和引用传递效率更高

## 1.47.静态变量什么时候初始化？

（1）只初始化一次，可以多次赋值，在主程序之前，编译器已经分配好了内存

（2）C++可以使用变量对静态局部变量进行初始化

## 1.48.const关键字的作用

（1）阻止一个变量被改变

（2）对于指针，可以指针本身为常量，也可以指定指针指向的变量为常量

（3）在函数声明的时候，形参形可以使用const修饰表示不能被修改

（4）对于类的成员函数，如果使用const修饰，表明它是一个常函数，不能修改类的成员函数

（5）const类型变量必须在定义的时候初始化，类的成员函数有const修饰的成员变量，则该变量必须要在类初始化列表的时候初始化

## 1.49.什么是类的继承？

类与类之间的关系有三种：

（1）has—A：包含关系，一个类包含多个类作为类的成员属性

（2）use—A：一个类使用另外一个类，通过友元以及传递参数实现

（3）is—A：继承关系，关系具有传递性

定义：一个类继承了另外一个类的成员属性以及成员方法，新的类称为子类或者派生类，被继承的类称为父类或者基类

## 1.50.友元是什么？

## 1.51.浅拷贝和深拷贝

浅拷贝：只是拷贝了地址，原对象被改变，浅拷贝的值也会发生改变

深拷贝：在计算机中重新开辟一块内存用于存放复制的对象

## 1.52.new和delete的实现原理

（1）new

对于简单类型，直接调用operator new分配内存

对于复杂类型，会额外保存数组的大小n，然后调用n次构造函数

（2）delete

对于简单类型，会直接调用free释放

对于复杂类型，会调用n次析构函数，n是new的时候保存的

## 1.53.

## 1.121.static_cast相比C语言的强转有什么优势？

（1）更加明显

（2）更明显的看到强转后的类型

## 1.121.C++的强转方式（衍生）

（1）static_cast：编译时类型转换，适用于相关类型的安全转换

（2）dynamic_cast：运行时类型转换，用于安全的向下转换，多态类型

（3）const_cast：去除或者添加const属性

（4）reinterpret_cast：用于低级别的，不安全的类型转换

## 1.122.memset(this, 0, sizeof(*this))的作用是什么？

~~~cpp
void* memset(void* ptr, int value, size_t num);
// 例如：
#include <cstring>

int main() {
    int arr[10];
    memset(arr, 0, sizeof(arr)); // 将数组的所有字节设为 0
    return 0;
}
~~~

主要用于更好的将多个变量同时初始化为0，快速初始化数组、清除内存

有几种方式不可以使用：

（1）类含有虚函数表

（2）类含有C++类型的对象

## 1.122.什么虚函数表？（衍生）

虚函数表是编译器在编译类时生成的指针数组，用于存储类中所有虚函数的指针，用于实现C++的多态

每个虚函数的类都有一张虚函数的表

虚指针：每个对象都会有一个虚指针，指向该类的虚函数表

## 1.123.什么是回调函数？

（1）当发生某件事情时，系统或其他函数会调用定义好的函数

（2）回调函数相当于一个中断函数，由系统在满足条件时自动调用

（3）回调函数是一个函数指针调用的函数

## 1.125.C++的编译过程是什么？

（1）预编译

主要处理源代码中”#“开头的预编译指令，处理规则主要有：

* 展开所有的#define的宏定义

* 处理所有的条件预编译指令

* 处理#include预编译指令

* 删除注释

* 添加行号和文件标识

（2）编译

在预编译生成的.i或者.ii文件，再进行词法分析、词语分析、语义分析、优化后生成相应的汇编代码文件

（3）汇编

将汇编代码转成可以编译的机器指令，汇编过程由汇编器完成，产生目标文件

（4）链接

将产生的不同目标文件进行链接，从而生成可执行文件。

## 1.125（衍生）条件预编译指令的作用



## 1.125（衍生）链接可以分为静态链接和动态链接



## 1.127.友元函数以及友元类

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间的数据共享机制。

友元的作用：友元的正确使用可以提升程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性更差。

（1）友元函数

友元函数是类外的普通函数，不属于任何类，可以访问其他成员的私有成员，需要在类的定义中声明所有的可以访问它的友元函数

友元函数可以是多个类的友元函数

~~~cpp
#include <iostream>
using namespace std;

class A
{
public:
    friend void set_show(int x, A &a);      //该函数是友元函数的声明
private:
    int data;
};

void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员
{
    a.data = x;
    cout << a.data << endl;
}
int main(void)
{
    class A a;
    set_show(1, a);
    return 0;
}
~~~

（2）友元类

友元类里面的每一个函数都是友元函数，但是在另外一个类里面也需要声明的。

需要注意的:

* 友元不能被继承
* 友元关系是单向的
* 友元关系不能传递

## 1.

## 1.131.介绍以一下常见的锁

（1）读写锁

读写锁允许多个线程同时读取资源，只允许一个线程写入资源，当有线程在写时，其他线程均不能访问资源。

适用于读多写少的场景

* 多个读取线程可以同时读取

* 写入线程互斥，只能有一个写入线程写入，写入与读取不能同时进行

* 写入线程优先读取线程

（2）互斥锁

互斥锁保证只能在同一时间有一个线程访问资源，其他线程必须等锁释放，才能继续访问。

（3）条件变量

条件变量用于线程间的协调，常用于一个线程等待某个条件后才继续执行。通常与std::unique_lock一起使用

条件变量解决了互斥锁只有两种状态的缺点，使用条件阻塞当前线程，在其他线程改变条件变量会通知条件变量唤醒被这个条件阻塞的线程。

互斥锁是线程间互斥的机制，条件变量是同步的机制

（4）自旋锁

自旋锁获取锁时不会等待，而是不断查询锁是否可用，因此适合在锁占用较短的情况下，如果锁占用时间较长，可能会导致CPU资源浪费

## 1.131.（衍生）什么是乐观锁和悲观锁？

（1）乐观锁

允许多个线程并发的读取或者处理共享资源，最后检测是否有冲突，适合冲突发生较少的场景。

（2）悲观锁

假设资源会被多个线程修改，在每次对资源进行操作时，线程会获取锁，确保没有其他线程访问，知道操作完成。

## 1.133.为什么不能把所有函数写成内联函数？内联函数的作用

内联函数：是一种将函数调用直接替换为代码的方式，避免了函数调用的开销

内联函数作用：

（1）减小函数调用开销

（2）加快代码执行效率

不能把所有函数都改成内联函数原因：

（1）会增大代码体积，增加内存消耗

（2）编译会变慢

（3）不适合复杂的函数

# 2.STL

## 2.33.STL的优先队列

优先队列是一个有权值观念的queue，顶部入口，底部出口，插入元素不是按照插入次序排列，根据权值排序，权值越高，排的越前。

实现原理：大根堆

底层容器：vector

# 3.C++11新标准

## 3.1.C++有哪些新特性

（1）nullptr替代了NULL

（2）lambda表达式

（3）auto、decltype推导类型

（4）基于范围的for循环

~~~cpp
for (auto& i : res) {}
~~~

（5）类和结构体中的初始化列表

（6）forward_list单向链表

（7）右值引用和move语义

## 3.1.左值与右值（衍生）

左值：可以取地址，可以放在赋值左边

右值：不可以取地址，不可以放在赋值左边

## 3.1.右值引用（衍生）

使用&&表示，用于避免不必要的复制，提高代码效率，实现移动语义

## 3.4.智能指针原理，常用智能指针以及实现

原理：智能指针是一个类，用来存储指针动态分配内存对象的指针，用于释放动态分配的内存对象，防止堆内存泄漏。

（1）shared_ptr

采用引用计数器的方法，允许多个智能指针指向同一个对象。每当多一个智能指针指向的时候，计数器加1。

~~~cpp
std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>(); // 创建一个 shared_ptr
std::shared_ptr<MyClass> ptr2 = ptr1; // 共享所有权

std::cout << "Reference count: " << ptr1.use_count() << std::endl; // 引用计数为 2
~~~

（2）unique_str

这是一种独占型的智能指针，确保指针的唯一所有权，一个非空的unique_str会把所有权全部从源指针转移给目标指针，源指针会置空。

~~~cpp
#include <memory>
std::unique_ptr<MyClass> ptr1 = std::make_unique<MyClass>(); // 创建一个 unique_ptr

std::unique_ptr<MyClass> ptr2 = std::move(ptr1); // 转移所有权
~~~

（3）weak_ptr

shared_ptr会有环形引用的问题，因此有了weak_ptr只引用，不计数。

~~~cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "MyClass constructor" << std::endl; }
    ~MyClass() { std::cout << "MyClass destructor" << std::endl; }
    void display() { std::cout << "Displaying MyClass" << std::endl; }
};

int main() {
    std::shared_ptr<MyClass> shared = std::make_shared<MyClass>(); // 创建一个 shared_ptr
    std::weak_ptr<MyClass> weak = shared; // 创建一个 weak_ptr，指向 shared_ptr 的对象

    if (auto ptr = weak.lock()) { // 使用 lock() 获取 shared_ptr
        ptr->display();
    }

    shared.reset(); // 重置 shared_ptr
    if (weak.expired()) {
        std::cout << "The object is no longer available" << std::endl;
    }

    return 0;
}
~~~

（4）auto_ptr

作用：解决有异常抛出时，内存泄漏的问题



## 3.8.智能指针的循环引用

循环引用是指使用多个智能指针时，出现了指针之间相互指向，从而出现环的场景。

# 4.内存管理

## 4.1.C++内存分区



# 5.知识星球面试总结

## 5.1.C++如何处理异常值？（联影）

（1）try-catch异常处理

    适用于处理不可预知的、严重的错误，如内存不足、硬盘读取错误、除以零等。这种方式较为优雅，但会带来一定的性能开销

（2）返回错误代码

    适合处理轻量级错误，尤其在性能要求较高的系统中。它的实现简单且开销较低，但会增加代码的复杂性，需要不断检查返回值

（3）断言（assert）

    用于开发和调试阶段，确保程序不会进入非法状态。如果程序在生产环境下，通常会禁用 assert

（4）std::optional返回可能的无效值

    在不想抛出异常的情况下处理函数返回的异常值。适用于那些函数结果可能为空或无效，但不会带来严重错误的情况。

## 5.2.给定数组a1,a2,a3,b1,b2,b3如何不使用额外的空间变成a1,b1,a2,b2,a3,b3?（联影）
可以使用交换的方法，但是交换的时候也不创建临时变量

~~~cpp
a = a + b;  // a = a + b
b = a - b;  // b = (a + b) - b = a
a = a - b;  // a = (a + b) - a = b
~~~

## 5.3.假设我在上海和北京有两个机房，里面有99.99%的数据一样，现在我需要对他们进行同步，由于全部进行网络传输成本比较大，有什么办法？（得物）

（1）基于差异的增量同步工具

增量同步的核心思想：只传输数据中的不同或者被修改的部分

rsync是一个增量同步工具，通过检查文件的变化，只传输有差异的部分

（2）数据库同步（如mysql的主从同步）

数据以数据库存储，通过数据库主从复制功能，实现机房数据同步。

原理：主库（如上海机房）会将数据变化写入二进制日志（binlog），从库（如北京机房）只接收这些变化日志并重放，从而实现同步

特点：只传输更新操作、支持高效的异地容灾和容错恢复

（3）自定义增量同步方案

根据实际需求，基于文件大小、文件修改时间等判断文件是否发生改变

* 文件哈系比较：在两地都生成文件的哈系（MD5 或 SHA256），通过比较哈系值

* 基于应用层的增量同步：某些应用（如数据处理系统）自身可能具备增量备份和同步机制，也可以利用这些机制进行数据同步。

## 5.4.构造函数和析构函数可以重载吗？

构造函数可以根据参数类型以及顺序和个数重载

析构函数不能重载

## 5.5.为什么析构函数不能重载？

（1）析构函数的唯一性

析构函数的作用是销毁对象，在对象生命周期结束时由编译器自动调用。

（2）销毁过程的确定性

析构函数的调用是自动的，允许析构函数重载会带来歧义。


# 6、面试总结

## 6.1.得物一面

### 6.1.1.对于unordered_map了解吗？实现原理是什么？

（1）unordered_map的底层是一个防冗余的哈希表（采用除数取余法）。哈系表最大的优点就是把存储和查找的时间复杂度降低，时间复杂度是O（1），代价是内存的消耗。

（2）使用一个范围较大的数组来存储元素，一般需要设计一个哈虚函数或者称为散列函数，使得每个元素的key可以和函数值对应，用这个函数值的数组单元存储这个元素，这个元素存储类所在的地方又称为”桶“

（3）当元素的key和函数值不是一一对应的时候，会产生哈系冲突，一般可以使用拉链法解决哈系冲突

衍生：

### 6.1.1（衍生1）哈系冲突有哪些解决方法？

（1）开放地址法：寻找表中下一个空闲位置来处理冲突，而不是使用额外的数据结构。有线性探测法、二次探测、双重散列

（2）链地址法：哈希表的每个槽位存储一个链表，所有映射到同一个位置的键值对都存储在链表中

（3）重哈希法：当哈希表冲突频率较高时，可以选择重新调整哈希表的大小

（4）完美哈希法：完美哈希是指通过设计特殊的哈希函数，使得所有键都能被唯一映射到哈希表中的不同槽位，完全避免冲突。

### 6.1.1（衍生2）对于map了解吗？实现原理是什么？

map是C++的一种关联容器，用于存储键值对，并根据键来快速查找值。它是基于红黑树实现的，因此键是有序存储的，查找、删除、插入的时间复杂度都是O（logn）

map的特点：键值存储、有序、自动平衡


### 6.1.1（衍生3）什么是红黑树，与平衡二叉树有什么区别？

平衡二叉树和红黑树都是用于查找提高、插入和删除操作效率的二叉搜索树，通过不同的平衡机制来保证最坏情况下依然高效。

* 平衡二叉树

高度平衡，平衡二叉树要求左子树和右子树的高度差不能超过1

* 红黑树

红黑树是一种弱平衡的二叉树，它比AVL树平衡条件更加宽松，插入和删除的效率更高

红黑树需要满足的条件

（1）每个节点要么是红色要么是黑色

（2）根节点必须是黑色

（3）每个叶节点都是黑色

（4）任何红色节点的子节点都必须是黑色（不能存在连续的红色节点）

（5）从任意一个节点到所有的叶节点，黑色节点数量相同

|特性|平衡二叉树|红黑树|
|---|---------|-----|
|平衡性|严格平衡，左右子树高度差为1|弱平衡，靠颜色规则|
|查找效率|O（logn）更高效|O（logn 比AVL低效|
|插入/删除效率|插入和删除后需要较多的旋转维护平衡|插入和删除更高效，旋转较少|
|旋转操作|需要更多旋转以维持严格平衡|较少的旋转和重新着色|
|应用场景|适用于查找操作较多的场景|适用于频繁插入、删除的场景|

### 6.1.1（衍生4）unordered_map和map的区别

构造函数：unordered_map需要哈系函数，map需要的是比较函数

存储结构：unordered_map使用哈系表存储，map使用红黑树存储

内存占用：unordered_map占用内存小于map

总体比较：unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。


### 6.1.2.C++中的锁有哪些？



### 6.1.3.编译的过程



### 6.1.4.死锁是什么？（死锁产生的必要条件）导致死锁的原因有哪些？

定义：死锁是指在多线程或者多进程的环境下，两个或多个任务互相等待释放资源，导致所有任务都无法进行的状态。

原因：

（1）互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个进程占用。如果此时还有其他进程请求该资源，则请求进程只能等待，直至占有该资源的进程用完释放。

（2）请求与保持条件：进程已经保持了一个资源，又请求新的资源而失败，此时请求资源被阻塞，但对自己的资源保持不放。

（3）不可抢占条件：进程已获得的资源在未使用之前被抢占，只能在进程使用完后释放

（4）循环等待条件：若干进程间形成一种头尾相接循环等待资源的关系

### 6.1.4.（衍生1）如何发现死锁？找到死锁位置

使用gdb调试死锁，步骤

~~~bash
先编译好可执行文件，并运行可执行文件
使用ps aux | grep 可执行文件名找到进程号
top -Hp 进程号查看cpu使用情况
使用su进入超级用户
使用gdb attach 进程号
使用thread apply all bt查看所有堆栈信息
info threads列出所有线程序号
thread 线程序号查看这个序号对应的进程
bt列出这个线程的信息
~~~

### 6.1.4.（衍生2）当多人合作时，由于代码不全是自己写的，如何找到死锁发生的位置？

（1）同样可以使用gdb调试

（2）使用死锁检测工具（valgrind）

（3）使用try_lock和超时机制

### 6.1.5.中止是什么？

### 6.1.6.编译如何找到已经链接的库？

ldd可以查看可执行文件依赖的库以及路径



## 6.2.中科创达一面

### 6.2.1.define、typedef、const区别？

#### （1）define宏定义

define又称为宏定义，

#### （2）typedef数据类型重命名



#### （3）const

const对象创建时必须初始化

默认状态下，const对象仅仅在文件里面有效，如果想在多个文件使用同一个const变量，可以在一个头文件里面声明

常量指针和指针常量

~~~cpp
int age = 39;
const int * p1 = &age; # const修饰*p1，可以改变指向，不能改变指向的值
int* const p2 = &age; # const修饰的p2，不可以改变指向，可以改变指向的值
~~~

底层const和顶层const

~~~cpp

~~~



#### （4）const和#define的区别？

const定义的常量是变量带类型，#define定义的是常数不带类型

#define在预处理阶段起作用，只是简单的文本替换，const在编译、链接过程起作用

#define只是简单的字符串替换没有类型检查，const会进行类型检查

#define预处理后占用代码段空间。const占用数据段空间

const不能重定义，#define可以通过#undef取消定义

#define可以文件被重复引用

#### （5）#define和typedef的区别？

typedef在编译阶段，具有类型检查功能，#define在预处理阶段，不会进行类型检查

#define没有作用域的限制，只要是预定义的宏，typedef有作用域的限制

typedef用于定义类型别名，#define不只是可以取别名，还可以定义变量、常量、编译开关等

例如

~~~cpp
#define P1 int*
typedef int* P2;
P1 a, b;//相当于int* a, b，此时a是int指针，b是int整数。
P2 a, b;//表示a和b都是int指针。
~~~

### 6.2.2.死锁的条件？

### 6.2.3.explicit关键字？

防止隐式类型转换，避免意外的类型转换，提高代码可读性和安全性。

### 6.2.4.你用过C++哪些关键字？

### 6.2.5.指针占用多少字节、64位操作系统？

4个字节，64位上是8个字节

### 6.2.6.进程间的通信方式？

消息队列、信号、信号量、socket、共享内存、

### 6.2.7.封装、继承、多态

### 6.2.8.多态的两种类型，实现原理是什么？

#### （1）静态多态（编译时多态）

编译时多态通过函数重载、运算符重载和模板等机制实现，在编译时就可以确定调用的函数版本。

可以在编译时决定调用哪个函数

#### （2）动态多态（运行时多态）

运行时多态通过继承和多态实现

编译器无法在编译的时候确定具体调用的函数，实际调用是运行时通过调用虚函数表实现

实现原理

* 虚函数表：每个包含虚函数类都含有虚函数表，存储了指向虚函数的指针，创建的对象虚指针指向虚函数表，通过表内存储的虚函数指针调用函数

* 虚指针：每个对象包含一个指针，指向所属类的虚函数表

### 6.2.9.class和struct区别？

### 6.2.10.空类的大小？

大小为1

### 6.2.11.拷贝构造函数和赋值符号的区别？

### 6.2.12.空类有哪些函数？

### 6.2.13.当方法不被修改时，const放在哪里？

### 6.2.14.const可以放在函数的哪里？

### 6.2.15.参数传递的方式？

### 6.2.16.你交换两个数字的时候用的什么方式？为什么？

### 6.2.17.当类中有static关键字时会发生什么？

### 6.2.18.模板了解吗？

### 6.2.19.常用的模板类型？

### 6.2.20.vector是不是模板类型？

### 6.2.21.了解vector的扩容机制吗？

### 6.2.22.vector插入元素是插入前面还是后面？

### 6.2.23.vector和队列的区别？

### 6.2.24.vector和链表对比

### 6.2.25.使用过的容器有哪些？

### 6.2.26.拷贝构造函数和析构函数可以为虚函数吗？

#### (1)拷贝构造函数不可以为多态

#### (2)析构函数可以为多态

析构函数被设计为虚函数是为了避免内存泄漏。

基类的析构函数没有声明为虚函数，删除基类指针只会调用基类析构函数，派生类特有的资源就可能得不到正确释放。

### 6.2.27.说一说define？和const的区别是什么？

（1）作用域不同

#define定义的常量是一个预处理宏，它在编译之前被替换，作用域为定义处到文件结束

const定义的常量是一个真正的变量，其作用域根据定义的位置而定，可以使局部或者全局作用域

（2）类型安全性

#define不具有类型检查，只是简单的文本替换，可能会有潜在的错误

const定义的常量具有类型检查，编译器会对其进行类型检查，提供更好的类型安全性。

（3）调试信息

调试时无法查看使用#define定义的常量的值

可以被调试器识别并显示其值

### 6.2.28.野指针是什么？

没有被初始化的指针

### 6.2.29.了解智能指针吗？用过哪些智能指针？

### 6.2.30.了解weak_ptr吗？

是为了避免shared_ptr循环引用

### 6.2.31.map的遍历方式？

（1）使用迭代器遍历（使用begin()和end()）

（2）std::for_each遍历

（3）反向迭代器遍历（使用rbegin()和rend()）

（4）使用std::map::key_comp

### 6.2.32.lambda表达式有了解吗？

## 6.3.4399一面

### 6.3.1.gdb调试的命令

### 6.3.2.linux常用的命令

### 6.3.3.查看网络状态的命令

### 6.3.4.进程和线程的优点和缺点

## 6.4.山石网科一面

### 6.4.1.两个栈如何实现队列

## 6.5.烽火通信一面

### 6.5.1.网络的分层

### 6.5.2.网络不同层之间是怎么互相支持的

### 6.5.3.不同的变量开辟的区域

### 6.5.4.静态变量的开辟区域、作用域、生命周期

### 6.5.5.函数指针和指针函数分别是什么

### 6.5.6.指针常数和常数指针

## 6.6.浩鲸科技一面

### 6.6.1.内存管理了解吗？内存开辟后会在哪？
### 6.6.2.使用过进程吗，如何使用进程
### 6.6.3.虚函数传递可以使用指针和引用吗
### 6.6.4.sql的理论
### 6.6.5.对于云的了解
### 6.6.6.为什么选择C++
### 6.6.7.有没有使用过python调用cpp或者使用cpp调用python
### 6.6.8.值传递、指针传递、引用传递的区别
### 6.6.9.linux下cpp如何编译，如何生成makefile文件
### 6.6.10.使用线程一般需要注意什么
### 6.6.11.多线程相比单线程有什么有点
### 6.6.12.虚函数一般是怎么实现的
### 6.6.13.进程间的通信方式
### 6.6.14.对于docker了解吗？它有什么作用

## 6.7.新华三一面

### 6.7.1.面向对象的三大语言特性：封装、继承、多态？

#### （1）封装



#### （2）继承



#### （3）多态

多态分为静态多态和动态多态

静态多态：重载和模板实现

动态多态：虚函数实现

### 6.7.2.对于一个类里面的方法和属性，什么时候用public、什么时候用private？

### 6.7.3.虚函数的实现原理？

#### （1）虚函数实现原理

注意事项

虚函数不能被声明为静态

#### （2）构造函数不可以为虚函数，析构函数可以为虚函数

#### （3）虚析构函数的必要性

虚析构函数是为了解决父类指针指向子类对象，释放子类对象资源的时候，释放不完全，造成的内存泄漏问题。

发生继承的时候，子类成员函数比父类多，父类指针无法指向子类的成员变量或者函数，父类指针无法指向子类析构函数，会导致资源泄漏问题。解决方法：

强制将父类指针转为子类指针

在父类中使用虚析构函数

#### （4）纯虚函数

可以声明一个虚函数为纯虚函数，语法格式。

~~~cpp
virtual 返回值类型 函数名 (函数参数) = 0;
~~~

纯虚函数没有函数体，只有声明，包含纯虚函数的类称为抽象类。

抽象类通常作为基类，让派生类实现纯虚函数，派生类必须实现纯虚函数才能实例化

### 6.7.4.纯虚表了解吗？



### 6.7.5.重写、重载、覆盖分别是什么？

#### （1）重载运算符

* 不能被重载的运算符？

长度运算符`sizeof`、条件运算符`: ?`、成员选择符`.`和域解析运算符`::`不能被重载。

* 重载运算符函数类别？

重载函数既可以作为类的成员函数，也可以作为全局函数

* 运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员

* 只能以成员函数重载的运算符？

箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。

* 成员函数重载和全局函数重载分别什么时候用？

对于+、-、*、/、==、!=一般使用全局函数重载，因为可以交换顺序

对于+=、-=、*=、/=一般使用成员函数重载，方便类的计算

#### （2）重载函数

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。

注意返回类型不可以仅仅通过返回值来重载函数。

#### （3）重写也可以称为覆盖

* 不在同一个作用域
* 函数名字相同
* 参数相同
* 基类函数必须有 virtual 关键字，不能有 static
* 返回值得相同
* 重写函数的访问修饰符号可以不同

#### （4）重定义

* 不在一个作用域
* 函数名字相同
* 返回值可以不同
* 参数相同：没有virtual时是重定义
* 参数不相同：有无virtual都是重定义

### 6.7.6.重写重载发生在类内还是类外还是类间？

重载函数可以发生在类内（成员重载函数）和类外（全局重载函数）

重写发生在类间

重定义也发生在类间

### 6.7.7.单例模式是什么？

是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。

### 6.7.8.单例模式的结构？

（1）私有构造函数：限制实例化，使得外部不能创建对象

（2）静态实例指针：保存唯一实例的静态指针，类内定义一个静态指针指向该实例

（3）公共静态方法：用于创建获取该类的唯一实例

~~~cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    // 1. 静态指针，指向唯一的实例
    static Singleton* instance;
    static std::mutex mtx; // 线程安全锁

    // 2. 私有构造函数，防止外部构造
    Singleton() {}

public:
    // 禁止拷贝构造和赋值操作符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 3. 静态方法获取唯一实例
    static Singleton* getInstance() {
        if (instance == nullptr) {  // 双重检查锁
            std::lock_guard<std::mutex> lock(mtx);
            if (instance == nullptr) {
                instance = new Singleton();
            }
        }
        return instance;
    }

    // 示例方法
    void showMessage() const {
        std::cout << "Hello, Singleton!" << std::endl;
    }
};

// 静态成员变量初始化
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    // 获取单例实例并调用方法
    Singleton* s = Singleton::getInstance();
    s->showMessage();
    return 0;
}
~~~

### 6.7.8.单例模式的作用？（拓展）

（1）节省资源，控制全局状态

（2）延迟实例化

（3）保证线程安全

### 6.7.9.vector实现的原理了解吗

#### （1）vector的扩容机制

vector扩容机制在底层上遵循动态数组的特性，空间不足时容纳新元素会重新分配一块更大内存的空间，将已有元素复制的新的内存区域，然后释放旧内存。

扩容倍数一般是2倍或者1.5倍。

#### （2）vector的实现原理

vector的实现主要依赖于动态分配以及指针。

### 6.7.10.了解list吗？

list是双向链表容器，容器的底层是双向链表实现的。

#### （1）主要特点

* list在常数范围内，任意位置插入删除元素，可以前后双向迭代。
* list和forward_list不同，forward_list只可以单向迭代
* 可以在任意位置，插入删除，不需要移动元素，效率高
* 访问比较慢，只能从头部或者尾部开始访问

#### （2）list的底层实现

主要是通过struct和class来实现的

## 6.8.南瑞一面

### 6.8.1.transformer和CNN的优缺点？什么时候适合使用transformer，什么时候适合使用CNN？

### 6.8.2.为什么要用两次3D-UNet网络

### 6.8.3.

## 6.9.新浪微博一面

### 6.9.1.找到数组中三个数字之和为target的元素？

## 6.10.荣耀一面

### 6.10.1.对于图像处理有了解过哪些？

## 6.11.荣耀二面

### 6.11.1.水平裁剪是如何减小显存的？

## 6.12.联影一面

### 6.12.1.自我介绍

### 6.12.2.介绍整体流程(项目一)

### 6.12.3.模拟数据是如何生成的(项目一)
ITK库，三维投影到2维平面，建立相机以及投影平面，在6个自由度，在给定的范围内随机平移

### 6.12.4.为什么需要做术中X线片的识别与检测(项目一)

由于在术中，病人位置会改变，为了找到三维CT的位置，使用2D-3D配准定位位置
### 6.12.5.关于精准率与召回率，还有auc指标(项目一)

### 6.12.6.对于配准能否介绍一下(项目一)

### 6.12.7.介绍CT分割流程(项目二)

### 6.12.8.CT分割数据集的分布(项目二)

### 6.12.9.为什么脊柱CT分割标签定位不使用逻辑推理(项目二)

### 6.12.10.介绍第三个项目

### 6.12.11.C++和python的熟悉程度

### 6.12.12.python的深拷贝和浅拷贝

### 6.12.13.C++的智能指针的作用

### 6.12.14.什么是PCA

### 6.12.15.对于我的建议：是否专精医学图像领域，还是需要对CV领域的知识有广泛的涉猎（反问）

### 6.12.16.如果有结果，大概什么时候会有通知（反问）


## 6.13.理想汽车

### 6.13.1.yolo的原理

### 6.13.2.yolov5和yolov8的区别

### 6.13.3.卷积的原理与作用

### 6.13.4.为什么需要卷积层来提取特征而不是使用整个图像来计算

### 6.13.5.yolov5的参数量

通常用正向推理的计算量(FLOPs)和参数个数(Parameters)来描述模型的复杂度

有参数的层一般包括

* 卷积层、全连接层、BN层、Embedding层、少数激活函数层

* 多数激活函数层、池化层、dropout层

yolov5有不同的参数模型，yolov5x的参数量大概是87M

### 6.13.5.（拓展）什么是FLOPS？

FLOPS：每秒浮点运算次数，可以理解为运算速度、用于衡量硬件的性能指标

FLOPs：浮点运算量，例如卷积层计算公式如下

$$
FLOPs = 2 * C_{out}* H_{out} * W_{out} * C_{in} * k^{2}
$$

### 6.13.6.yolov5卷积层的数量

n:

s:

m:

l:

x:

### 6.13.7.yolov5的损失函数怎么计算？

（1）位置损失

目标边界框的位置预测和真实位置之间的差异，yolov5用均方差计算位置损失

（2）置信度损失

置信度损失主要是用于衡量模型对于目标是否存在的预测和真实情况，
包括目标存在的置信度和目标不存在的置信度，使用二元交叉损失来计算置信度损失

（3）类别损失

模型用来衡量模型对于目标类别的预测和真实类比的差异，用交叉熵损失来计算类别损失

### 6.13.8.神经网络的神经元的数量和参数量是不是一致的？

神经元的数量和参数的数量是不一样的，通常神经元的数量远远小于参数的数量

例如全连接层：

参数量 = 输入神经元数量×输出神经元数量在+ 偏置神经元数量

### 6.13.9.python的多线程怎么写，怎么实现？

（1）直接使用 threading.Thread 类创建线程


（2）继承 threading.Thread 类并创建一个自定义的线程类。

### 6.13.10.python的多线程是否真的是多线程，实现原理是什么？

python的多线程特别是Cpython由于GIL的存在，使得python的多线程并不是真正的多线程

（1）什么是GIL？

GIL是python解释器的一个机制，确保同一时间只有一个线程能够执行python字节码
GIL 存在的原因是为了简化内存管理，因为 Python 对象的引用计数需要是线程安全的

（2）I/O 密集型任务（合适使用多线程）

（3）CPU 密集型任务（效果不佳，考虑多进程）

### 6.13.11.python有哪些数据类型？

### 6.13.12.python字典的key可以为的变量类型？

### 6.13.13.list和元组的区别？

### 6.13.14.项目难点以及如何解决的？

## 6.14.联影二面

### 6.14.1.对于map的计算

### 6.14.2.map50和map50：95区别

### 6.14.3.ap和pr曲线的联系

### 6.14.4.对于同一个类别，ap50和ap95的pr曲线走向？

### 6.14.5.豪斯多夫距离是什么？

## 6.15.图灵深视（实习）

### 6.15.1.yolov5的损失函数

yolo系列的损失一般包括分类损失、置信度损失、定位损失

### 6.15.2.yolov5与yolov8有什么不同？yolov8训练的时候为什么要关闭mosaic

### 6.15.3.对于yolov5的Mosaic数据增强你知道是什么吗？为什么会效果好？

Mosaic数据增强的基本原理是随机选择四张图片，通过随机缩放、随机裁剪和随机排列的方式将它们拼接成一张新的图片。在这个过程中，每张图片都有对应的框框，将四张图片拼接后，可以得到一张新的图片和对应的框框

步骤：
（1）随机选取图片拼接基准点坐标（xc，yc），另随机选取四张图片。
（2）四张图片根据基准点，分别经过 尺寸调整 和 比例缩放 后，放置在指定尺寸的大图的左上，右上，左下，右下位置。
（3）根据每张图片的尺寸变换方式，将映射关系对应到图片标签上。
（4）依据指定的横纵坐标，对大图进行拼接。处理超过边界的检测框坐标。
优点：
（1）增加数据集多样性。随机选择四张图像进行组合，组合得到的图像个数比原图多
（2）增强模型的鲁棒性。混合四张具有不同语义信息的图片，可以让模型检测超出常规语境的目标。
（3）加强批归一化的效果。模型设置BN，训练会尽量增大样本总量，BN原理为计算每一个特征层的均值和方差，如果批样本总量增大，那么 BN 计算的均值和方差就越接近于整个数据集的均值和方差，效果越好。
（4）Mosaic算法有助于提升目标检测性能。Mosaic 数据增强图像由四张原始图像拼接而成，这样每张图像会有更大概率包含小目标。

### 6.15.4.你用过什么数据增强的方法？

数据增强是一种用于增加训练数据集多样性的方法，可以帮助模型更好地范化，减少过拟合。

（1）翻转和旋转

（2）裁剪和缩放

（3）平移

（4）颜色调整

（5）噪声添加

（6）模糊和锐化

（7）剪切变换

### 6.15.5.你遇到过拟合的问题吗？遇到过拟合你是怎么解决的？

过拟合是指模型在训练集上表现良好，但在测试集（或新数据）上表现较差的情况。通常出现过拟合的原因是模型过于复杂，从而过度拟合了训练集的噪声和细节。
解决方法：
（1）数据增强
（2）简化模型，降低模型的复杂度
（3）迁移学习给模型提供一个比较好的初值
（4）加入dropout。以一定概率让某些神经元输出为0

### 6.15.6.yolov5对于小目标检测效果不好，有什么好的方法改进？

有人提出基于轻量级卷积注意力模块(CBAM)与采用加权双向特征金字塔网络模块(Bi-FPN)的改进

（1）轻量级卷积注意力模块（CBAM）

（2）加权双向特征金字塔模块（Bi-FRN）

### 6.15.7.BN层一般在什么地方？

一般会在加在激活函数前面，但也有加在激活函数后面的

BN是什么？

不同样本之间归一化
(1)训练阶段

$$
\mu_B = \frac{1}{m}\Sigma_{i=1}^{m}x_{i}
$$
$$
\sigma_B^{2} = \frac{1}{m}\Sigma_{i=1}^{m}(x_{i}-\mu_{B})^{2}
$$
$$
\hat x_{i} = \frac{x_{i}-\mu_{B}}{\sqrt{\sigma_{B}^{2} + \epsilon}}
$$
$$
y_{i} = \gamma\hat x_{i} + \beta
$$

(2)测试阶段
测试时，标准差、均值、γ和 β 都使用训练全局求出的值

$$
\mu_{test} = E(\mu_{batch})
$$
$$
\sigma_{test}^{2} = \frac{m}{m - 1}E(\sigma_{batch}^{2})
$$
BN相当于做线性变换
$$
BN(X_{test}) = \gamma * \frac{X_{test}- \mu_{test}}{\sqrt{\sigma_{test}^{2} + \epsilon}} + \beta
$$
\* BN层的作用
1、加快网络的训练和收敛速度
2、控制梯度爆炸防止梯度消失
3、防止过拟合

### 6.15.8.图像transformer的序列是怎么生成的？

主要分为四步

（1）图像切块
（2）展平和线性映射
（3）位置编码
（4）序列生成

### 6.15.9.图像自注意力机制是怎么计算的？

### 6.15.10.transformer的feature map是怎么计算的

### 6.15.11.你用过什么分割网络

使用过Unet、nnUnet

### 6.15.12.UNet为什么会效果好？

U-Net的带有跳跃连接的编解码结构能够融合不同层级的特征，医学图像本身的固定化结构和小样本性，共同使得U-Net成为医学图像分割领域的最佳模型

### 6.15.13.除了这两个项目，你还做过什么项目？

还做过一个标志点识别的任务，主要是识别术中X线片的椎体标志点，主要负责的是模拟数据生成部分

### 6.15.14.AI鉴定是使用分类网络判别真假吗？(反问)

使用检测网络识别鉴别区域，然后不同不同区域鉴别，根据不同区域的权重判别

### 6.15.15.鉴别需要有多个角度判别吗？(反问)

不需要，因为已经做过数据增强了

### 6.15.16.如果被录取，多久需要上手？(反问)

## 6.16.浪潮一面

### 6.16.1.学过的语言是python和C++，还有其他语言吗？

是的，主要学了python和C++

### 6.16.2.python的反转字符串用什么方法？

使用reverse方法
~~~python
''.join(reversed('123456789'))
~~~
使用字符串切片
~~~python
a='123456789' 
a = a[::-1]
~~~
### 6.16.3.linux如果要查看文件头几行和后几行，需要什么命令？
```bash
head -n 10 /etc/profile # 开头几行
tail  -n 5 /etc/profile # 末尾几行
```
### 6.16.4.项目中用到了什么模型？

在第一个项目中主要用到的是3DUnet以及一个spatialConfiguration-Net
在第二个项目中主要使用的yolov5以及RTDETR网络

## 6.17.联影三面

### 6.17.1.左值和右值有什么区别？

左值：表达式结束后依然存在的对象。指向具体的内存位置，可以取得地址值，一般出现在赋值操作符左侧。

右值：暂时存在，不能赋值给另外一个值。通常是数据值或者无法通过标识符直接反问的临时对象。

区别：

（1）左值有明确的内存地址，右值没有固定的内存地址。

（2）左值代表长期存在的对象，右值代表临时或者即将销毁的对象。

（3）右值可以被移动，左值通常不行，除非显示的转换为右值引用。

（4）可以声明左值引用指向左值，右值引用指向右值，优化资源使用。

### 6.17.2.写一道排除重复元素的函数

~~~cpp

~~~



### 6.18.1.引用和指针区别？什么时候使用？

引用：

指针：

### 6.18.2.在大型数据的时候为什么使用引用而不使用指针

### 6.18.3.