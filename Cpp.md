<!--
 * @Description: 
 * @version: 
 * @Author: 帅磊240108 2158097607@xiaomi.com
 * @Date: 2024-08-30 23:10:10
 * @LastEditors: ShuaiLei
 * @LastEditTime: 2024-10-01 16:46:09
-->
# 一、C++基础语法

## 1.1.main函数在执行之前和之后执行的代码可能是什么？
main函数在执行之前一般都会初始化系统相关资源

(1)设置栈指针

(2)初始化静态变量和全局变量

(3)将未初始化的全局变量赋初值

(4)全局对象初始化，在main之前调用构造函数

(5)将main函数参数传递给main函数

main函数执行之后

(1)全局对象的析构函数会在main函数之后执行

## 1.1.拓展
.data 段: 存储已初始化的全局和静态变量，初始值在程序开始运行时已经设置好

.bss 段: 存储未初始化的全局和静态变量，在程序启动时自动初始化为零。

## 1.2.结构体的内存对齐

### 1.2.1.内存对齐的优点

(1)提高内存访问速度

(2)减少内存访问的速度

(3)优化硬件性能

(4)减少编译器优化困难

(5)避免内存碎片

### 1.2.2.结构体内存对齐
结构体成员按声明顺序存储，第一个成员地址和结构体地址相同

没有特殊声明时，一般按照size最大的成员对齐

## 1.3.指针与引用的区别
（1）指针是一个变量，存储的是一个地址，引用跟原来的变量实质是一个东西，是别名

（2）指针可以为空，但是引用不能为空，而且引用在定义的时候必须要初始化，初始化后不可再改变

（3）sizeof指针得到的是指针的大小，sizeof引用得到的是引用所指向变量的大小

（4）不存在指向空值的引用，但存在指向空值的指针

## 1.4.关于传递参数使用引用还是指针

需要返回函数内部局部变量的时候用指针

对栈空间比较敏感的时候例如递归的时候选用引用

类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式


## 1.5.堆与栈的区别

申请方式不同：栈是由系统自动分配的，堆是自己申请和释放的

申请大小限制不同：栈顶和栈底是之前预设的，大小固定

申请效率不同：栈由系统分配，速度快，不会有碎片，堆由程序员分配，速度慢，会有碎片

分配方式：堆都是动态分配的，栈有静态分配和动态分配

空间大小：堆是不连续的内存区域，堆的空间比较大，比较灵活。栈是连续的内存区域，大小是操作系统预订好的

分配效率：堆由C++函数库提供，机制复杂，堆的效率比栈低很多。栈是系统提供的数据结构，计算机在底层对栈提供支持

## 1.6.堆快一点还是栈快一点

栈更快一点，操作系统对栈提供支持，会分配专门的寄存器存放地址，栈的出栈入栈也比较简单，有专门的指令执行，栈的效率比较高也比较快

堆的操作是C/C++函数库提供的，在分配内存的时候需要一定的算法寻找合适的内存

## 1.7.区别函数组指针、指针数组、函数声明、函数指针

~~~cpp
int *p[10]  // 指针数组
int (*p)[10]  // 数组指针
int *p(int)  // 函数声明
int (*p)(int) // 函数指针
~~~

## 1.8.new/delete以及malloc/free异同

相同点：都用于内存的申请和释放

不同点：

（1）new和delete是C++的运算符，malloc和free是C语言标准库函数

（2）new是自动分配大小的，malloc需要手工计算，new是类型安全的，malloc不是的

（3）new和delete会调用构造函数和析构函数，malloc/free不会

（4）malloc/free需要库文件，new/delete没有


## 1.9.new和delete是如何实现的

（1）new实现的过程，首先调用operator new的标准库函数，分配足够大的内存，接下来运行构造函数，指定初始化构造对象，返回这个对象的指针。

（2）delete实现的过程，对指针指向的对象运行析构函数，调用名为operator delete的标注库函数释放内存。


## 1.10.malloc和new的区别

（1）malloc和free是标准库函数，new和delete是运算符，支持重载

（2）malloc和free仅仅分配和回收内存空间，不能调用构造和析构函数，而new/delete会调用

（3）malloc返回的是void类型指针，需要强制转换类型，new直接返回相对应的类型指针


## 1.11.已经有了malloc和free为什么C++还需要new和delete？

在对非基本数据类型的时候，需要构造和析构函数，所以需要new和delete

## 1.12.被free的内存会立即返回给操作系统吗？

被free的内存会被ptmalloc使用双链表保存起来，当下一次申请会找合适的返回，避免频繁的系统调用，占用过多的系统资源。

## 1.13.宏定义和函数的区别

（1）宏在预处理阶段完成替换，之后会参与编译，执行更快

（2）宏定义没有返回值

（3）宏定义没有参数类型，不需要类型检查

（4）宏定义语句没有分号

## 1.14.宏定义和typedef的区别

（1）宏主要用于常量替换，而typedef用于定义类型别名

（2）宏替换发生在编译前，属于文本插入替换，typedef是编译的一部分

（3）宏不会检测类型，typedef会检查类型

（4）宏不是语句，不需要加分号，typedef是语句，需要加分号

## 1.15.变量声明和定义的区别

（1）声明并不分配内存空间，定义会分配空间

（2）相同变量可以多处声明但是只能一次定义

## 1.16.strlen和sizeof的区别

（1）sizeof是运算符，strlen是字符处理的库函数

（2）sizeof参数可以是任何数据类型，strlen的参数只能是字符指针同时结尾是'\0'的字符串

## 1.17.常量指针和指针常量的区别

~~~cpp
int const *p; // 指针常量
int *const p; // 常量指针
~~~
（1）指针常量：指向一个只读的值

（2）常量指针：必须初始化，不变的是指针本身的值，而非指向的值

主要通过const修饰谁来判断，例如int const *p修饰的是 *p所以 *p不能被改变，是指针常量

int *const p其中const修饰的是p 所以p不能被改变，是常量指针

## 1.18.C++与C语言的区别

（1）面向对象和面向过程

C++支持面向对象，侧用使用类和对象来管理代码

C语言面向过程，侧重使用函数解决问题

（2）继承

C++支持继承，允许一个子类继承一个或者多个父类，达到代码复用的目的

C语言没有继承的概念

（3）函数重载

C++支持函数通过参数名和参数个数的重载

C语言不支持重载，函数名必须唯一

（4）模板

C++支持模板，支持静态和动态形式的多态

C语言不存在模板

（5）内存管理

C++使用new和delete管理内存

C语言使用malloc和free管理内存

（6）标准库

C++的STL的标准库比C语言的丰富

## 1.19.C++与java的区别

（1）java语言更为简洁，完全面向对象，JVM可以安装在任何操作系统上，可移植性强。

（2）java没有指针，引入了真正的数组，不会有数组操作等指针越界

（3）java使用接口（interface）代替了C++的抽象类

（4）内存管理，C++类和对象通过析构函数回收，而java不需要自己管理内存

（5）桌面程序C++更实用，web端java更方便

## 1.20.C++中的struct和class的区别

（1）两者都拥有成员函数，公有私有部分

（2）使用class完成的工作同样可以使用class完成

（3）成员如果不指定公私有，则class默认私有，struct默认公有

（4）class继承默认是私有继承，而struct是公有继承

## 1.21.C++与C语言的struct

（1）C语言中的struct是自定义数据类型，C++中struct是抽象数据类型，支持成员函数定义

（2）C语言的struct没有权限设置，成员不可以是函数

（3）C++中，struct增加了访问权限，且可以和类一样有成员函数

## 1.22.define宏定义和const的区别

（1）编译阶段

define在编译预处理阶段起作用，const在编译和运行的时候起作用

（2）安全性

define只做替换，不做类型检查和替换，const修饰的数据类型，编译器会对其进行类型安全检查

（3）内存占用

define替换后，内存中会有多个相同的备份，但宏定义的数据不会分配内存空间，const修饰的内存变量只是值不能改变，但还是会分配内存空间

## 1.23.C++中的static和const的作用

（1）static

static用于静态变量和函数，在程序执行期间只会初始化一次，并且离开作用域时不会被销毁。

类中的成员变量static只与类关联，不与类的对象关联

（2）const

用于定义常量，变量在初始化后不能被修改

防止变量被修改，增强代码可读性和安全性

## 1.24.C++的顶层const和底层const

（1）顶层const

const修饰的变量本身就是一个常量,const修饰的是整个对象，变量的值不可更改

~~~cpp
const int x = 10;  // x 是一个顶层 const 变量，x 的值不能被修改
int* const p2 = &y; // p2 是一个常量指针，p2 不能改变指向的地址，但可以通过 p2 修改 y
~~~

（2）底层const

指的是const修饰的变量所指向的对象是一个常量，修饰的是指针所指向的对象，指针所指向的内容不可修改

~~~cpp
int y = 20;
const int* p1 = &y; // p1 是指向 const int 的指针，不能通过 p1 修改 y
const int* const p3 = &y; // p3 是一个常量指针指向常量，p3 不能改变指向的地址，也不能通过 p3 修改 y
~~~

区分作用

（1）执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const

（2）使用的命名的强制类型转换const_cast时，只能改变运算对象的底层const

## 1.25.数组名和指针的区别

（1）二者均可以通过增减偏移量来访问数组中的元素

（2）数组名不是真正意义上的指针，可以理解为常量指针，所以数组名没有自增自减等操作

（3）数组名是常量指针，不能改变

## 1.26.什么是函数签名？

在C++中，函数签名是指函数的名称、参数列表和参数类型的组合，不包括函数的返回类型

函数签名的组成

（1）函数名：函数的名称

（2）参数列表：参数个数、类型、顺序，不包括参数名

不匹配的签名：

（1）参数类型和顺序不同

（2）参数个数不同

（3）函数返回类型不同：尽管返回类型不属于函数签名的一部分，但对于虚函数的重写，返回类型必须要和基类中的虚函数匹配。

## 1.27.override和final关键字

（1）override关键字

确保子类的函数正确的重写了基类中的虚函数。仅用于函数，尤其是虚函数的重写。编译器会检查函数签名是否一致，确保确实重写了虚函数

（2）final关键字

防止类被进一步继承或者防止虚函数被进一步重写。可用于类和虚函数

## 1.28.拷贝初始化和直接初始化

当用于类类型对象的时候，初始化的拷贝形式和直接形式有所不同：直接初始化会调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先会使用构造函数创建临时对象，然后拷贝构造函数将临时对象拷贝到创建的对象。

## 1.29.初始化和赋值的区别

（1）简单类型

初始化和赋值没有什么区别

（2）类对象

初始化：创建对象赋初值的过程，初始化发生在对象的创建阶段，是对象生命周期的开始

赋值：对象已经创建并初始化后，对值进行更新的过程，是对象生命周期的中间阶段

## 1.30.extern "C" 的用法

为了正确在C++中使用C，在程序中extern C后相当于告诉编译器这部分代码是C语言写的

（1）C++代码中使用C语言

（2）在C++头文件中使用

（3）用不同语言协同开发时

## 1.31.野指针与悬空指针

定义

（1）野指针：没有被初始化的指针。

（2）悬空指针：指针最初指向的内存已经被释放了的指针

解决方法

（1）野指针：定义指针变量时及时初始化或者置空。

（2）悬空指针：释放指针所指向的内存空间后及时置空。

## 1.32.C++的类型安全

（1）操作符new返回的具体类型的指针，而不是void*

（2）引入const关键字代表#define

（3）一些define宏可被改写为inline函数

（4）C++提供了dynamic_cast关键字

## 1.33.C++重载、重写以及隐藏的区别

（1）重载

是指同一范围定义中的同名成员函数才存在重载函数，主要特点是函数名相同，参数类型和数目不同，不能出现仅仅依靠返回值不同来区分的函数。重载与成员函数是否是虚函数无关。

（2）重写

是指在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须要是虚函数。重写的函数，参数类型、参数个数以及返回类型都必须相同

重写与重载的区别

* 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系

* 重写要求参数列表相同，重载要求参数列表不同，返回值不要求

* 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表之间关系选择函数体


（3）隐藏

是指某些情况下，派生类中的函数屏蔽了基类中的同名函数

* 两个函数参数相同，但是基类函数不是虚函数，和重写的区别就在于基类函数不是虚函数。

* 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏


## 1.34.C++有哪几种构造函数

默认构造函数

初始化构造函数

拷贝构造函数

移动构造函数

## 1.35.浅拷贝和深拷贝的区别

（1）浅拷贝

浅拷贝只是拷贝一个指针，拷贝的指针和原指针指向同一个地方，

（2）深拷贝

深拷贝不仅拷贝值，还开辟新的一片空间存放新的值

## 1.36.内联函数和宏定义的区别

（1）在使用时，宏只做简单的字符串替换，内联函数可以进行参数检查，具有返回值

（2）内联函数在编译时直接将函数代码直接嵌入到目标代码中，省去函数调用的开销，并进行参数类型检查，具有返回值

（3）宏定义需要注意格式，否则容易出现歧义，内联函数不会出现歧义

（4）内联函数有类型检查，语法判断等功能


## 1.37.public、protected、private访问继承权限/public/protected/private的区别

* public的变量和函数都可以在类的内部外部访问到

* protected的变量和函数都只可以类的内部和派生类中访问

* private修饰的元素只能在类内访问 

（一）访问权限

派生类对基类成员有两种访问方式

* 内部访问：由派生类的成员函数对基类中继承来的成员的访问

* 外部访问：在派生类外部，通过派生类的对象对基类中继承来的成员的访问

（二）继承权限

（1）派生类继承自基类的成员权限状态有：public、protected、private、不可见，排序为public>protected>private

（2）派生类对于基类成员的访问权限取决于两点：继承方式、基类成员在基类中的访问权限

（3）基类成员在派生类中的访问权限不得高于继承方式指定的权限：高于继承方式指定的权限则下降为继承权限，低于继承权限则不调整，基类的private成员在任何方式下都是不可见的，例如：

* public继承+private成员--->不可见
* public继承+protected成员--->pretected
* protected继承+public成员--->protected
* private继承+public成员--->private
* private继承+protected成员--->private

## 1.38.如何用代码判断大小端存储?

* 大端存储：字数据的高字节存储在低地址中

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |

* 小端存储：字数据的低字节存储在低地址中

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |

使用代码判断：

~~~cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
~~~

在socket编程中，需要用将小端存储的ip地址转为大端存储，才能进行网络传输

## 1.39.volatile、mutable和explicit关键字

* volatile关键字

volatile是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素修改。当遇到这个关键字修饰的变量，编译器对访问该变量的代码不再优化，提供对特殊地址的稳定访问。系统会从所在的内存去访问。多线程被几个任务共享的变量需要定义为volatile类型。

* mutable关键字

当需要在const函数里面修改一些与类状态无关的数据成员，这个函数就应该用multable来修饰

* explicit关键字

explicit是C++中的关键字，防止隐式转换，通常用于构造函数，防止编译器在某些情况下自动调用构造函数进行隐式转换，以确保代码的可读性和安全性。

## 1.40.什么情况下会调用拷贝构造函数？

* 在使用类的实例化对象去初始化另一个对象时
* 函数的参数是类的对象时（非引用传递）
* 函数返回值是函数体局部对象类对象时，这时会发生NRV优化，返回值是值传递，会调用拷贝构造函数（linux下g++不会发生拷贝构造函数）

## 1.41.new有几种方式？

new有三种方式：plain new、nothrow new、placement new。

（1）plain new

这个就是普通的new，也是最常用的new

（2）nothrow new

nothrow new分配的时候不抛出异常，会返回NULL

（3）placement new

placement new允许在一块已经分配好的内存上重新构造对象或者对象数组

placement new构造的对象数组，需要显示的调用析构函数释放，不能使用delete，否则可能导致内存泄漏等问题

## 1.42.C++的异常处理的方法？

（1）try、throw和catch关键字

（2）函数异常声明列表

在定义函数时，可能知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出的异常。

（3）C++标准异常类exception

exception包含的异常类：bad_typeid，bad_cast,bad_alloc,out_of_range

## 1.43.static用法和作用

（1）隐藏



（2）static是用来保持变量内容的持久

存储在静态区域的变量只会初始化一次，也是唯一一次初始化。静态区域变量：全局变量、静态变量

（3）static变量默认初始化为0

（4）C++类成员声明

* 函数体中static变量作用范围为函数体，下次调用会维持上次的值

* 在类中的static变量属于整个类所有，对类的所有对象只有一份拷贝

* static成员函数属于这个类，没有this指针，只能访问static成员变量

* static成员函数不能被virtual修饰

## 1.44.指针和const用法



## 1.125.C++的编译过程是什么？

（1）预编译

主要处理源代码中”#“开头的预编译指令，处理规则主要有：

* 展开所有的#define的宏定义

* 处理所有的条件预编译指令

* 处理#include预编译指令

* 删除注释

* 添加行号和文件标识

（2）编译

在预编译生成的.i或者.ii文件，再进行词法分析、词语分析、语义分析、优化后生成相应的汇编代码文件

（3）汇编

将汇编代码转成可以编译的机器指令，汇编过程由汇编器完成，产生目标文件

（4）链接

将产生的不同目标文件进行链接，从而生成可执行文件。

## 1.125（衍生）条件预编译指令的作用



## 1.125（衍生）链接可以分为静态链接和动态链接




## 1.131.介绍以一下常见的锁

（1）读写锁

读写锁允许多个线程同时读取资源，只允许一个线程写入资源，当有线程在写时，其他线程均不能访问资源。

适用于读多写少的场景

* 多个读取线程可以同时读取

* 写入线程互斥，只能有一个写入线程写入，写入与读取不能同时进行

* 写入线程优先读取线程

（2）互斥锁

互斥锁保证只能在同一时间有一个线程访问资源，其他线程必须等锁释放，才能继续访问。

（3）条件变量

条件变量用于线程间的协调，常用于一个线程等待某个条件后才继续执行。通常与std::unique_lock一起使用

条件变量解决了互斥锁只有两种状态的缺点，使用条件阻塞当前线程，在其他线程改变条件变量会通知条件变量唤醒被这个条件阻塞的线程。

互斥锁是线程间互斥的机制，条件变量是同步的机制

（4）自旋锁

自旋锁获取锁时不会等待，而是不断查询锁是否可用，因此适合在锁占用较短的情况下，如果锁占用时间较长，可能会导致CPU资源浪费

## 1.131.（衍生）什么是乐观锁和悲观锁？

（1）乐观锁

允许多个线程并发的读取或者处理共享资源，最后检测是否有冲突，适合冲突发生较少的场景。

（2）悲观锁

假设资源会被多个线程修改，在每次对资源进行操作时，线程会获取锁，确保没有其他线程访问，知道操作完成。



# 2.知识星球面试总结

## 2.1.C++如何处理异常值？（联影）

（1）try-catch异常处理

    适用于处理不可预知的、严重的错误，如内存不足、硬盘读取错误、除以零等。这种方式较为优雅，但会带来一定的性能开销

（2）返回错误代码

    适合处理轻量级错误，尤其在性能要求较高的系统中。它的实现简单且开销较低，但会增加代码的复杂性，需要不断检查返回值

（3）断言（assert）

    用于开发和调试阶段，确保程序不会进入非法状态。如果程序在生产环境下，通常会禁用 assert

（4）std::optional返回可能的无效值

    在不想抛出异常的情况下处理函数返回的异常值。适用于那些函数结果可能为空或无效，但不会带来严重错误的情况。

## 2.2.给定数组a1,a2,a3,b1,b2,b3如何不使用额外的空间变成a1,b1,a2,b2,a3,b3?（联影）
可以使用交换的方法，但是交换的时候也不创建临时变量

~~~cpp
a = a + b;  // a = a + b
b = a - b;  // b = (a + b) - b = a
a = a - b;  // a = (a + b) - a = b
~~~

## 2.3.假设我在上海和北京有两个机房，里面有99.99%的数据一样，现在我需要对他们进行同步，由于全部进行网络传输成本比较大，有什么办法？（得物）

（1）基于差异的增量同步工具

增量同步的核心思想：只传输数据中的不同或者被修改的部分

rsync是一个增量同步工具，通过检查文件的变化，只传输有差异的部分

（2）数据库同步（如mysql的主从同步）

数据以数据库存储，通过数据库主从复制功能，实现机房数据同步。

原理：主库（如上海机房）会将数据变化写入二进制日志（binlog），从库（如北京机房）只接收这些变化日志并重放，从而实现同步

特点：只传输更新操作、支持高效的异地容灾和容错恢复

（3）自定义增量同步方案

根据实际需求，基于文件大小、文件修改时间等判断文件是否发生改变

* 文件哈系比较：在两地都生成文件的哈系（MD5 或 SHA256），通过比较哈系值

* 基于应用层的增量同步：某些应用（如数据处理系统）自身可能具备增量备份和同步机制，也可以利用这些机制进行数据同步。

## 2.4.构造函数和析构函数可以重载吗？

构造函数可以根据参数类型以及顺序和个数重载

析构函数不能重载

## 2.5.为什么析构函数不能重载？

（1）析构函数的唯一性

析构函数的作用是销毁对象，在对象生命周期结束时由编译器自动调用。

（2）销毁过程的确定性

析构函数的调用是自动的，允许析构函数重载会带来歧义。


# 3、面试总结

## 3.1.得物

### 3.1.1.对于unordered_map了解吗？实现原理是什么？

（1）unordered_map的底层是一个防冗余的哈希表（采用除数取余法）。哈系表最大的优点就是把存储和查找的时间复杂度降低，时间复杂度是O（1），代价是内存的消耗。

（2）使用一个范围较大的数组来存储元素，一般需要设计一个哈虚函数或者称为散列函数，使得每个元素的key可以和函数值对应，用这个函数值的数组单元存储这个元素，这个元素存储类所在的地方又称为”桶“

（3）当元素的key和函数值不是一一对应的时候，会产生哈系冲突，一般可以使用拉链法解决哈系冲突

衍生：

### 3.1.1（衍生1）哈系冲突有哪些解决方法？

（1）开放地址法：寻找表中下一个空闲位置来处理冲突，而不是使用额外的数据结构。有线性探测法、二次探测、双重散列

（2）链地址法：哈希表的每个槽位存储一个链表，所有映射到同一个位置的键值对都存储在链表中

（3）重哈希法：当哈希表冲突频率较高时，可以选择重新调整哈希表的大小

（4）完美哈希法：完美哈希是指通过设计特殊的哈希函数，使得所有键都能被唯一映射到哈希表中的不同槽位，完全避免冲突。

### 3.1.1（衍生2）对于map了解吗？实现原理是什么？

map是C++的一种关联容器，用于存储键值对，并根据键来快速查找值。它是基于红黑树实现的，因此键是有序存储的，查找、删除、插入的时间复杂度都是O（logn）

map的特点：键值存储、有序、自动平衡


### 3.1.1（衍生3）什么是红黑树，与平衡二叉树有什么区别？

平衡二叉树和红黑树都是用于查找提高、插入和删除操作效率的二叉搜索树，通过不同的平衡机制来保证最坏情况下依然高效。

* 平衡二叉树

高度平衡，平衡二叉树要求左子树和右子树的高度差不能超过1

* 红黑树

红黑树是一种弱平衡的二叉树，它比AVL树平衡条件更加宽松，插入和删除的效率更高

红黑树需要满足的条件

（1）每个节点要么是红色要么是黑色

（2）根节点必须是黑色

（3）每个叶节点都是黑色

（4）任何红色节点的子节点都必须是黑色（不能存在连续的红色节点）

（5）从任意一个节点到所有的叶节点，黑色节点数量相同

|特性|平衡二叉树|红黑树|
|---|---------|-----|
|平衡性|严格平衡，左右子树高度差为1|弱平衡，靠颜色规则|
|查找效率|O（logn）更高效|O（logn 比AVL低效|
|插入/删除效率|插入和删除后需要较多的旋转维护平衡|插入和删除更高效，旋转较少|
|旋转操作|需要更多旋转以维持严格平衡|较少的旋转和重新着色|
|应用场景|适用于查找操作较多的场景|适用于频繁插入、删除的场景|

### 3.1.1（衍生4）unordered_map和map的区别

构造函数：unordered_map需要哈系函数，map需要的是比较函数

存储结构：unordered_map使用哈系表存储，map使用红黑树存储

内存占用：unordered_map占用内存小于map

总体比较：unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。


### 3.1.2.C++中的锁有哪些？




### 3.1.3.编译的过程



